# -*- coding: utf-8 -*-
"""
/***************************************************************************
 UpravjalecElaborata
                                 A QGIS plugin
 Ta vtičnik je namenjen za obdelavo elaborata, uvoz izvozne datoteke iz katastrskega sistema (XML), urejanje točk in nato izvoz v pravilen XML format za uvozno datoteko na katastrski sistem
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-01
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Tadej Tersek
        email                : tadej.tersek03@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QTableWidgetItem, QHeaderView
import os
import xml.etree.ElementTree as ET
import json
from qgis.core import QgsVectorLayer, QgsField, QgsFeature, QgsPointXY, QgsGeometry, QgsProject, QgsSimpleMarkerSymbolLayer, QgsSymbol, QgsSimpleLineSymbolLayer, QgsSimpleFillSymbolLayer, QgsRasterLayer, QgsCoordinateReferenceSystem, QgsRendererCategory, QgsCategorizedSymbolRenderer, QgsProperty, QgsSingleSymbolRenderer, QgsSymbolLayer, QgsFeatureRequest, QgsLayerTreeNode
from PyQt5.QtCore import QVariant
from collections import defaultdict, deque
import random
import colorsys
import base64
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .upravljalec_elaborata_dockwidget import UpravjalecElaborataDockWidget
import os.path


class UpravjalecElaborata:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'UpravjalecElaborata_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Upravljalec Elaborata')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'UpravjalecElaborata')
        self.toolbar.setObjectName(u'UpravjalecElaborata')

        #print "** INITIALIZING UpravjalecElaborata"

        self.pluginIsActive = False
        self.dockwidget = None

    def nalozi_xml(self):
        """Odpre dialog in prebere XML datoteko"""
        file_path, _ = QFileDialog.getOpenFileName(self.dockwidget, "Izberi XML datoteko", "", "XML datoteke (*.xml)")

        if not file_path:
            return
        
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup("Upravljalec Elaboratov")
        if group:
            # Kopiraj seznam, ker ga bomo spreminjali med iteracijo
            for child in list(group.children()):
                if child.nodeType() == QgsLayerTreeNode.NodeLayer:
                    # Odstrani sloj iz projekta (in s tem tudi iz grupe)
                    QgsProject.instance().removeMapLayer(child.layerId())
                elif child.nodeType() == QgsLayerTreeNode.NodeGroup:
                    # Odstrani podskupino iz grupe
                    group.removeChildNode(child)

        try:
            tree = ET.parse(file_path)
            root = tree.getroot()

            # Čistimo tabelo
            self.dockwidget.tableWidget_data.setRowCount(0)
            self.dockwidget.tableWidget_data.setColumnCount(2)
            self.dockwidget.tableWidget_data.setHorizontalHeaderLabels(["Element", "Vrednost"])
            self.dockwidget.tableWidget_data.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

            """
            for elem in root.iter():
                tag = elem.tag
                text = elem.text.strip() if elem.text else ""
                row = self.dockwidget.tableWidget_data.rowCount()
                self.dockwidget.tableWidget_data.insertRow(row)
                self.dockwidget.tableWidget_data.setItem(row, 0, QTableWidgetItem(tag))
                self.dockwidget.tableWidget_data.setItem(row, 1, QTableWidgetItem(text))
            """
            self.add_xml_to_table(root)

            self.prikazi_poligone_iz_xml(root)
            self.prikazi_daljice_iz_xml(root)
            self.prikazi_stavbe_iz_xml(root)
            self.prikazi_tocke_iz_xml(root)    

            self.reorder_layers()    

            """ BREADTH-FIRST SEARCH
            queue = deque([root])  # Start with the root in a queue

            while queue:
                node = queue.popleft()  # Remove from front
                print(node.tag, node.attrib, node.text)
                
                # Add all child elements to the end of the queue
                queue.extend(list(node))
            """      

        except Exception as e:
            QMessageBox.critical(self.dockwidget, "Napaka", f"Napaka pri branju XML datoteke:\n{str(e)}")    


    def prikazi_tocke_iz_xml(self, root):
        # Poišči <datoteka> znotraj <parcele>
        datoteka_elem = root.find(".//parcele/datoteka")
        if datoteka_elem is None or datoteka_elem.text is None:
            QMessageBox.warning(self.dockwidget, "Napaka", "V XML-ju ni najdenih podatkov o točkah.")
            return

        # Preberi JSON iz CDATA
        json_str = datoteka_elem.text
        podatki = json.loads(json_str)
        self.last_json = podatki  # <-- store for refresh
        tocke = podatki.get("podatki", {}).get("tocke", [])
        print("Število točk:", len(tocke))

        vlayer = QgsVectorLayer("Point?crs=EPSG:3794", "Tocke iz XML", "memory")
        if not vlayer.isValid():
            QMessageBox.critical(self.dockwidget, "Napaka", "Začasni sloj ni veljaven!")
            return

        pr = vlayer.dataProvider()
        pr.addAttributes([
            QgsField("tockaEid", QVariant.String),
            QgsField("sifKo", QVariant.Int),
            QgsField("stevilkaTocke", QVariant.Int),
            QgsField("sprememba", QVariant.String)
        ])
        vlayer.updateFields()

        # Add virtual fields for e and n
        vlayer.addExpressionField('x($geometry)', QgsField('e', QVariant.Double))
        vlayer.addExpressionField('y($geometry)', QgsField('n', QVariant.Double))

        features = []
        for t in tocke:
            if t.get("sprememba") not in ("N", "S", "D"):
                continue
            feat = QgsFeature()
            #print(f"i: {i}, e: {t["e"]}, n: {t["n"]}, tockaEid: {t.get("tockaEid")}, sifKo: {t.get("sifKo")}, stevilkaTocke: {t.get("stevilkaTocke")}")
            feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(t["e"], t["n"])))
            feat.setAttributes([
                str(t.get("tockaEid")),
                t.get("sifKo"),
                t.get("stevilkaTocke"),
                t.get("sprememba")
            ])
            features.append(feat)

        pr.addFeatures(features)
        vlayer.updateExtents()
        QgsProject.instance().addMapLayer(vlayer)
        self.move_layer_to_group(vlayer)
        self.set_points_style(vlayer)

        self.add_world_basemap()    

        vlayer.startEditing()
        self.iface.setActiveLayer(vlayer)
        self.points_layer = vlayer  # <-- store reference

        # Connect geometryChanged signal
        vlayer.geometryChanged.connect(self.refresh_edges_and_polygons)

    def prikazi_daljice_iz_xml(self, root):
        # Poišči <datoteka> znotraj <parcele>
        datoteka_elem = root.find(".//parcele/datoteka")
        if datoteka_elem is None or datoteka_elem.text is None:
            QMessageBox.warning(self.dockwidget, "Napaka", "V XML-ju ni najdenih podatkov o daljicah.")
            return

        # Preberi JSON iz CDATA
        json_str = datoteka_elem.text
        podatki = json.loads(json_str)
        tocke = podatki.get("podatki", {}).get("tocke", [])
        daljice = podatki.get("podatki", {}).get("daljice", [])

        # Ustvari slovar za hitro iskanje koordinat po tockaEid
        tocka_map = {str(t["tockaEid"]): (t["e"], t["n"], t["sprememba"]) for t in tocke}

        vlayer = QgsVectorLayer("LineString?crs=EPSG:3794", "Daljice iz XML", "memory")
        if not vlayer.isValid():
            QMessageBox.critical(self.dockwidget, "Napaka", "Začasni linijski sloj ni veljaven!")
            return

        pr = vlayer.dataProvider()
        pr.addAttributes([
            QgsField("daljicaEid", QVariant.String),
            QgsField("tockaEidZac", QVariant.String),
            QgsField("tockaEidKon", QVariant.String),
            QgsField("status", QVariant.Int)
        ])
        vlayer.updateFields()

        features = []
        for d in daljice:
            if d.get("sprememba") not in ("N", "S", "D"):
                continue
            zac = tocka_map.get(str(d["tockaEidZac"]))
            kon = tocka_map.get(str(d["tockaEidKon"]))
            if zac is None or kon is None:
                print(f"Daljica preskočena (manjka točka): {d}")
                continue
            if (zac[2] not in ("N", "S", "D") or kon[2] not in ("N", "S", "D")):
                print(f"Daljica preskočena zaradi neveljavnih točk")
                continue
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolylineXY([
                QgsPointXY(zac[0], zac[1]),
                QgsPointXY(kon[0], kon[1])
            ]))
            feat.setAttributes([
                str(d.get("daljicaEid")),
                str(d.get("tockaEidZac")),
                str(d.get("tockaEidKon")),
                d.get("status")
            ])
            features.append(feat)

        pr.addFeatures(features)
        vlayer.updateExtents()
        QgsProject.instance().addMapLayer(vlayer)
        self.move_layer_to_group(vlayer)
        self.set_edges_style(vlayer)

    def prikazi_poligone_iz_xml(self, root):
        # Poišči <datoteka> znotraj <parcele>
        datoteka_elem = root.find(".//parcele/datoteka")
        if datoteka_elem is None or datoteka_elem.text is None:
            QMessageBox.warning(self.dockwidget, "Napaka", "V XML-ju ni najdenih podatkov o poligonih.")
            return

        # Preberi JSON iz CDATA
        json_str = datoteka_elem.text
        podatki = json.loads(json_str)
        tocke = podatki.get("podatki", {}).get("tocke", [])
        daljice = podatki.get("podatki", {}).get("daljice", [])
        parcele = podatki.get("podatki", {}).get("parcele", [])
        parceleDaljice = podatki.get("podatki", {}).get("parceleDaljice", [])

        # Slovar za hiter dostop do koordinat
        tocka_map = {str(t["tockaEid"]): (t["e"], t["n"]) for t in tocke if t.get("sprememba") in ("N", "S", "D")}
        daljice_map = {str(d["daljicaEid"]): (str(d["tockaEidZac"]), str(d["tockaEidKon"])) for d in daljice if d.get("sprememba") in ("N", "S", "D")}
        parceleDaljice_map = defaultdict(list)
        for p in parceleDaljice:
            if p.get("sprememba") in ("N", "S", "D"):
                parceleDaljice_map[str(p["daljicaEid"])].append(p)

        # Pripravi sloj
        vlayer = QgsVectorLayer("Polygon?crs=EPSG:3794", "Parcele iz XML", "memory")
        if not vlayer.isValid():
            QMessageBox.critical(self.dockwidget, "Napaka", "Začasni poligonski sloj ni veljaven!")
            return

        pr = vlayer.dataProvider()
        pr.addAttributes([
            QgsField("parcelaEid", QVariant.String),
            QgsField("stevilkaParcele", QVariant.String),
            QgsField("povrsina", QVariant.Double),
            QgsField("hue", QVariant.Double)
        ])
        vlayer.updateFields()

        parcela2daljice_outer = defaultdict(list)
        parcela2daljice_holes = defaultdict(lambda: defaultdict(list))
        sharedDaljice = defaultdict(list)
        for pd in parceleDaljice:
            if pd.get("sprememba") not in ("N", "S", "D"):
                continue
            parcela_id = str(pd["parcelaEid"])
            pripadnost = pd.get("pripadnost", 0)
            daljica_id = str(pd["daljicaEid"])
            zacTockaEid = daljice_map.get(daljica_id, (None, None))[0]
            konTockaEid = daljice_map.get(daljica_id, (None, None))[1]
            if zacTockaEid is None or konTockaEid is None:
                print(f"Daljica preskočena (manjka točka): {daljica_id}")
                continue
            sharedDaljice[parcela_id + zacTockaEid].append(pd)
            sharedDaljice[parcela_id + konTockaEid].append(pd)
            if pripadnost == 0:
                parcela2daljice_outer[parcela_id].append(daljica_id)
            else:
                parcela2daljice_holes[parcela_id][str(pripadnost)].append(daljica_id)

        features = []
        for parcela in parcele:
            if parcela.get("sprememba") not in ("N", "S", "D"):
                continue
            parcela_id = str(parcela["parcelaEid"])
            # Outer ring
            daljica_ids = parcela2daljice_outer.get(parcela_id, [])
            outer_coords = self.reconstruct_ring(parcela_id, daljica_ids, sharedDaljice, daljice_map, tocka_map, parceleDaljice_map)
            if len(outer_coords) < 3:
                continue

            # Holes (inner rings)
            holes = []
            for hole_ids in parcela2daljice_holes[parcela_id].values():
                hole_coords = self.reconstruct_ring(parcela_id, hole_ids, sharedDaljice, daljice_map, tocka_map, parceleDaljice_map)
                if len(hole_coords) >= 3:
                    holes.append(hole_coords)

            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolygonXY([outer_coords] + holes))
            feat.setAttributes([
                parcela_id,
                parcela.get("stevilkaParcele", ""),
                parcela.get("povrsina", None),
                random.random()
            ])
            features.append(feat)

        pr.addFeatures(features)
        vlayer.updateExtents()
        QgsProject.instance().addMapLayer(vlayer)
        self.move_layer_to_group(vlayer)
        self.set_polygons_style(vlayer)

    def reconstruct_ring(self, parcelaId, daljica_ids, sharedDaljice, daljice_map, tocka_map, parceleDaljice_map, isStavba=False):
        coords = []

        name = "parcelaEid"
        if isStavba:
            name = "stavbaParcelaEid"

        if len(daljica_ids) == 0:
            return coords
        
        prevDaljica = None

        cDaljica = daljica_ids[0]
        if isStavba:
            print("cDaljica:", cDaljica)
        daljica_entries = parceleDaljice_map.get(str(cDaljica), [])
        if isStavba:
            print("daljica_entries:", daljica_entries)
        cParcelaDaljica = next((pd for pd in daljica_entries if str(pd[name]) == parcelaId), None)
        if isStavba:
            print("cParcelaDaljica:", cParcelaDaljica)
        parcela_id = str(cParcelaDaljica.get(name, None))
        tockaEid = str(cParcelaDaljica.get("tockaEid", None))
        zacTockaEid = daljice_map.get(cDaljica, (None, None))[0]
        konTockaEid = daljice_map.get(cDaljica, (None, None))[1]
        if tockaEid != konTockaEid:
            temp = zacTockaEid
            zacTockaEid = konTockaEid
            konTockaEid = temp    
        coords.append(QgsPointXY(tocka_map.get(zacTockaEid, (None, None))[0], tocka_map.get(zacTockaEid, (None, None))[1]))

        while len(coords) == 1 and cDaljica != prevDaljica or coords[0] != coords[-1]:
            prevDaljica = cDaljica
            shared = sharedDaljice.get(parcela_id + tockaEid, [])
            for pd in shared:
                otherDaljica_id = str(pd.get("daljicaEid"))
                if cDaljica != otherDaljica_id and otherDaljica_id in daljica_ids:
                    cDaljica = otherDaljica_id
                    daljica_entries = parceleDaljice_map.get(str(cDaljica), [])
                    cParcelaDaljica = next((pd for pd in daljica_entries if str(pd[name]) == parcelaId), None)
                    parcela_id = str(cParcelaDaljica.get(name, None))
                    tockaEid = str(cParcelaDaljica.get("tockaEid", None))
                    zacTockaEid = daljice_map.get(cDaljica, (None, None))[0]
                    konTockaEid = daljice_map.get(cDaljica, (None, None))[1]
                    if tockaEid != konTockaEid:
                        temp = zacTockaEid
                        zacTockaEid = konTockaEid
                        konTockaEid = temp    
                    coords.append(QgsPointXY(tocka_map.get(zacTockaEid, (None, None))[0], tocka_map.get(zacTockaEid, (None, None))[1]))
                    break 

        return coords        

    def prikazi_stavbe_iz_xml(self, root):
        # Poišči <datoteka> znotraj <stavbe>
        datoteka_elem = root.find(".//stavbe/datoteka")
        if datoteka_elem is None or datoteka_elem.text is None:
            QMessageBox.warning(self.dockwidget, "Napaka", "V XML-ju ni najdenih podatkov o stavbah.")
            return

        # Preberi JSON iz CDATA
        json_str = datoteka_elem.text
        podatki = json.loads(json_str)
        stavbe = podatki.get("podatki", {}).get("stavbe", [])

        datoteka_elem = root.find(".//parcele/datoteka")
        if datoteka_elem is None or datoteka_elem.text is None:
            QMessageBox.warning(self.dockwidget, "Napaka", "V XML-ju ni najdenih podatkov o stavbah in njenih mejah.")
            return

        # Preberi JSON iz CDATA
        json_str = datoteka_elem.text
        podatki = json.loads(json_str)

        stavbeParcele = podatki.get("podatki", {}).get("stavbeParcele", [])
        stavbeParceleDaljice = podatki.get("podatki", {}).get("stavbeParceleDaljice", [])
        daljice = podatki.get("podatki", {}).get("daljice", [])
        tocke = podatki.get("podatki", {}).get("tocke", [])

        self.last_stavbe_json = {
            "stavbe": stavbe,
            "stavbeParcele": stavbeParcele,
            "stavbeParceleDaljice": stavbeParceleDaljice,
            "daljice": daljice,
            "tocke": tocke
        }

        if not stavbe:
            QMessageBox.warning(self.dockwidget, "Napaka", "V XML-ju ni najdenih podatkov o stavbah.")
            return

        vlayer = QgsVectorLayer("Polygon?crs=EPSG:3794", "Stavbe iz XML", "memory")
        if not vlayer.isValid():
            QMessageBox.critical(self.dockwidget, "Napaka", "Začasni poligonski sloj za stavbe ni veljaven!")
            return

        pr = vlayer.dataProvider()
        pr.addAttributes([
            QgsField("stavbaEid", QVariant.String),
            QgsField("stavbaParcelaEid", QVariant.String),
            QgsField("usingDaljice", QVariant.Bool)
        ])
        vlayer.updateFields()

        daljice_map = {str(d["daljicaEid"]): (str(d["tockaEidZac"]), str(d["tockaEidKon"])) for d in daljice if d.get("sprememba") in ("N", "S", "D")}

        stavbe_map = {str(s["stavbaEid"]): s for s in stavbe if s.get("sprememba") in {"N", "D", "S"}}
        stavbe_parcele_map = defaultdict(list)
        for sp in stavbeParcele:
            if (sp.get("sprememba") not in ("N", "S", "D")):
                continue
            if str(sp["stavbaEid"]) not in stavbe_map:
                print(f"Stavba {sp['stavbaEid']} ni najdena v seznamu stavb.")
                continue
            stavbe_parcele_map[str(sp["stavbaEid"])].append(str(sp["stavbaParcelaEid"]))

        stavbe_parcele_daljice_map = defaultdict(list)
        parcela2daljice_holes = defaultdict(lambda: defaultdict(list))
        sharedDaljice = defaultdict(list)
        stavbe_parcele_daljice_map_obj = defaultdict(list)
        for spd in stavbeParceleDaljice:
            if spd.get("sprememba") not in ("N", "S", "D"):
                continue

            parcela_id = str(spd["stavbaParcelaEid"])
            daljica_id = str(spd["daljicaEid"])
            pripadnost = spd.get("pripadnost", 0)
            zacTockaEid = daljice_map.get(daljica_id, (None, None))[0]
            konTockaEid = daljice_map.get(daljica_id, (None, None))[1]
            if zacTockaEid is None or konTockaEid is None:
                print(f"Daljica preskočena (manjka točka): {daljica_id}")
                continue
            sharedDaljice[parcela_id + zacTockaEid].append(spd)
            sharedDaljice[parcela_id + konTockaEid].append(spd)
            
            stavbe_parcele_daljice_map_obj[daljica_id].append(spd)

            if pripadnost == 0:
                stavbe_parcele_daljice_map[parcela_id].append(daljica_id)
            else:
                parcela2daljice_holes[parcela_id][str(pripadnost)].append(daljica_id)            
        
        #daljice_map = {str(d["daljicaEid"]): (str(d.get("tockaEidZac")), str(d.get("tockaEidKon"))) for d in daljice if d.get("sprememba") in {"N", "S", "D"}}
        tocka_map = {str(t["tockaEid"]): (t["e"], t["n"]) for t in tocke if t.get("sprememba") in {"N", "S", "D"}}

        features = []
        for stavba_id, stavbe_info in stavbe_map.items():
            drawn = False
            for spd in stavbe_parcele_map.get(stavba_id, []):

                stavba_parcela_id = spd
                daljice_ids = stavbe_parcele_daljice_map.get(stavba_parcela_id, [])  
                outer_coords = self.reconstruct_ring(stavba_parcela_id, daljice_ids, sharedDaljice, daljice_map, tocka_map, stavbe_parcele_daljice_map_obj, isStavba=True)    
                if len(outer_coords) < 3:
                    print(f"Stavba parcela {stavba_parcela_id} nima dovolj koordinat za risanje.")
                    continue

                holes = []
                for hole_ids in parcela2daljice_holes[stavba_parcela_id].values():
                    hole_coords = self.reconstruct_ring(stavba_parcela_id, hole_ids, sharedDaljice, daljice_map, tocka_map, stavbe_parcele_daljice_map_obj, isStavba=True)
                    if len(hole_coords) >= 3:
                        holes.append(hole_coords)

                feat = QgsFeature()
                feat.setGeometry(QgsGeometry.fromPolygonXY([outer_coords] + holes))

                drawn = True

                feat.setAttributes([
                    str(stavbe_info.get("stavbaEid")),  # stavbaEid
                    stavba_parcela_id,  # stavbaParcelaEid)
                    drawn
                ])
                features.append(feat)

            if not drawn:
                geom = None
                for tryGeom in ("tlorisGeom", "nadzemniGeom", "podzemniGeom", "terenGeom"):
                    if stavbe_info.get(tryGeom):
                        geom = stavbe_info.get(tryGeom)
                        break  
                if geom:
                    try:
                        geom = QgsGeometry.fromWkt(geom)
                        drawn = True
                        feat = QgsFeature()
                        feat.setGeometry(geom)
                        feat.setAttributes([
                            str(stavbe_info.get("stavbaEid")),
                            None,
                            False
                        ])
                        features.append(feat)
                        print(f"  Uporabljam geom za stavba_id: {stavba_id}")
                    except Exception as e:
                        print(f"  Napaka pri branju geom za stavba_id {stavba_id}: {e}")

            if not drawn:
                print(f"Stavba parcela {stavba_id} nima veljavnih koordinat ali geometrije.")
                continue
                
        if not features:
            QMessageBox.warning(self.dockwidget, "Napaka", "Ni najdenih veljavnih stavb.")
            return
        pr.addFeatures(features)
        vlayer.updateExtents()
        QgsProject.instance().addMapLayer(vlayer)
        self.move_layer_to_group(vlayer)
        self.set_stavbe_style(vlayer)

    def refresh_edges_and_polygons(self, fid=None, geom=None):
        print("Refreshing edges and polygons...")

        if fid is not None:
            feat = next(self.points_layer.getFeatures(QgsFeatureRequest(fid)), None)
            if feat:
                print(f"Premaknjena točka: {feat['tockaEid']}")
        # Remove old layers
        for name in ["Daljice iz XML"]:
            for lyr in QgsProject.instance().mapLayers().values():
                if lyr.name() == name:
                    QgsProject.instance().removeMapLayer(lyr.id())

        # Build tocka_map from current points layer
        tocka_map = {}
        for feat in self.points_layer.getFeatures():
            eid = str(feat["tockaEid"])
            pt = feat.geometry().asPoint()
            tocka_map[eid] = (pt.x(), pt.y(), feat["sprememba"])

        # Use the original JSON structure for daljice, parcele, parceleDaljice
        # You must store it when loading XML:
        # self.last_json = podatki

        # Recreate edges
        daljice = self.last_json.get("podatki", {}).get("daljice", [])
        vlayer = QgsVectorLayer("LineString?crs=EPSG:3794", "Daljice iz XML", "memory")
        pr = vlayer.dataProvider()
        pr.addAttributes([
            QgsField("daljicaEid", QVariant.String),
            QgsField("tockaEidZac", QVariant.String),
            QgsField("tockaEidKon", QVariant.String),
            QgsField("status", QVariant.Int),
            QgsField("sprememba", QVariant.String)
        ])
        vlayer.updateFields()
        features = []
        for d in daljice:
            if d.get("sprememba") not in ("N", "S", "D"):
                continue
            zac = tocka_map.get(str(d["tockaEidZac"]))
            kon = tocka_map.get(str(d["tockaEidKon"]))
            if zac is None or kon is None:
                continue
            if (zac[2] not in ("N", "S", "D") or kon[2] not in ("N", "S", "D")):
                print(f"Daljica preskočena zaradi neveljavnih točk")
                continue
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolylineXY([
                QgsPointXY(zac[0], zac[1]),
                QgsPointXY(kon[0], kon[1])
            ]))
            feat.setAttributes([
                str(d.get("daljicaEid")),
                str(d.get("tockaEidZac")),
                str(d.get("tockaEidKon")),
                d.get("status"),
                d.get("sprememba")
            ])
            features.append(feat)
        pr.addFeatures(features)
        vlayer.updateExtents()
        QgsProject.instance().addMapLayer(vlayer)
        self.move_layer_to_group(vlayer)
        self.set_edges_style(vlayer)

        # Recreate polygons (parcele)
        parcele = self.last_json.get("podatki", {}).get("parcele", [])
        parceleDaljice = self.last_json.get("podatki", {}).get("parceleDaljice", [])

        # Slovar za hiter dostop do koordinat
        daljice_map = {str(d["daljicaEid"]): (str(d["tockaEidZac"]), str(d["tockaEidKon"])) for d in daljice if d.get("sprememba") in ("N", "S", "D")}
        parceleDaljice_map = defaultdict(list)
        for p in parceleDaljice:
            if p.get("sprememba") in ("N", "S", "D"):
                parceleDaljice_map[str(p["daljicaEid"])].append(p)

        parcela2daljice = defaultdict(list)
        for pd in parceleDaljice:
            parcela2daljice[str(pd["parcelaEid"])].append(str(pd["daljicaEid"]))

        # Remove old "Parcele iz XML" layer before creating a new one
        old_hues = {}
        for lyr in list(QgsProject.instance().mapLayers().values()):
            if lyr.name() == "Parcele iz XML":
                print("parcele layer found")
                for feat in lyr.getFeatures():
                    old_hues[str(feat["parcelaEid"])] = feat["hue"]
                QgsProject.instance().removeMapLayer(lyr.id())
                break

        # Now create the new polygon layer and add features as before
        vlayer = QgsVectorLayer("Polygon?crs=EPSG:3794", "Parcele iz XML", "memory")
        pr = vlayer.dataProvider()
        pr.addAttributes([
            QgsField("parcelaEid", QVariant.String),
            QgsField("stevilkaParcele", QVariant.String),
            QgsField("povrsina", QVariant.Double),
            QgsField("hue", QVariant.Double)  # <-- add hue field!
        ])
        vlayer.updateFields()

        parcela2daljice_outer = defaultdict(list)
        parcela2daljice_holes = defaultdict(lambda: defaultdict(list))
        sharedDaljice = defaultdict(list)
        for pd in parceleDaljice:
            if pd.get("sprememba") not in ("N", "S", "D"):
                continue
            parcela_id = str(pd["parcelaEid"])
            pripadnost = pd.get("pripadnost", 0)
            daljica_id = str(pd["daljicaEid"])
            zacTockaEid = daljice_map.get(daljica_id, (None, None))[0]
            konTockaEid = daljice_map.get(daljica_id, (None, None))[1]
            if zacTockaEid is None or konTockaEid is None:
                print(f"Daljica preskočena (manjka točka): {daljica_id}")
                continue
            sharedDaljice[parcela_id + zacTockaEid].append(pd)
            sharedDaljice[parcela_id + konTockaEid].append(pd)
            if pripadnost == 0:
                parcela2daljice_outer[parcela_id].append(daljica_id)
            else:
                parcela2daljice_holes[parcela_id][str(pripadnost)].append(daljica_id)

        features = []
        for parcela in parcele:
            if parcela.get("sprememba") not in ("N", "S", "D"):
                continue
            parcela_id = str(parcela["parcelaEid"])
            # Outer ring
            daljica_ids = parcela2daljice_outer.get(parcela_id, [])
            outer_coords = self.reconstruct_ring(parcela_id, daljica_ids, sharedDaljice, daljice_map, tocka_map, parceleDaljice_map)
            if len(outer_coords) < 3:
                continue

            # Holes (inner rings)
            holes = []
            for hole_ids in parcela2daljice_holes[parcela_id].values():
                hole_coords = self.reconstruct_ring(parcela_id, hole_ids, sharedDaljice, daljice_map, tocka_map, parceleDaljice_map)
                if len(hole_coords) >= 3:
                    holes.append(hole_coords)

            oldHue = old_hues.get(parcela_id, random.random())
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolygonXY([outer_coords] + holes))
            feat.setAttributes([
                parcela_id,
                parcela.get("stevilkaParcele", ""),
                parcela.get("povrsina", None),
                oldHue
            ])
            features.append(feat)

        pr.addFeatures(features)
        vlayer.updateExtents()
        QgsProject.instance().addMapLayer(vlayer)
        self.move_layer_to_group(vlayer)
        self.set_polygons_style(vlayer)
        self.points_layer.startEditing()
        self.iface.setActiveLayer(self.points_layer)

        ## STAVBE REFRESH
        for lyr in list(QgsProject.instance().mapLayers().values()):
            if lyr.name() == "Stavbe iz XML":
                QgsProject.instance().removeMapLayer(lyr.id())
                break

        if hasattr(self, "last_stavbe_json"):
            stavbe = self.last_stavbe_json["stavbe"]
            stavbeParcele = self.last_stavbe_json["stavbeParcele"]
            stavbeParceleDaljice = self.last_stavbe_json["stavbeParceleDaljice"]
            daljice = self.last_stavbe_json["daljice"]

            vlayer = QgsVectorLayer("Polygon?crs=EPSG:3794", "Stavbe iz XML", "memory")
            pr = vlayer.dataProvider()
            pr.addAttributes([
                QgsField("stavbaEid", QVariant.String),
                QgsField("stavbaParcelaEid", QVariant.String),
                QgsField("usingDaljice", QVariant.Bool)
            ])
            vlayer.updateFields()

            daljice_map = {str(d["daljicaEid"]): (str(d["tockaEidZac"]), str(d["tockaEidKon"])) for d in daljice if d.get("sprememba") in ("N", "S", "D")}

            stavbe_map = {str(s["stavbaEid"]): s for s in stavbe if s.get("sprememba") in {"N", "D", "S"}}
            stavbe_parcele_map = defaultdict(list)
            for sp in stavbeParcele:
                if (sp.get("sprememba") not in ("N", "S", "D")):
                    continue
                if str(sp["stavbaEid"]) not in stavbe_map:
                    print(f"Stavba {sp['stavbaEid']} ni najdena v seznamu stavb.")
                    continue
                stavbe_parcele_map[str(sp["stavbaEid"])].append(str(sp["stavbaParcelaEid"]))

            stavbe_parcele_daljice_map = defaultdict(list)
            parcela2daljice_holes = defaultdict(lambda: defaultdict(list))
            sharedDaljice = defaultdict(list)
            stavbe_parcele_daljice_map_obj = defaultdict(list)
            for spd in stavbeParceleDaljice:
                if spd.get("sprememba") not in ("N", "S", "D"):
                    continue

                parcela_id = str(spd["stavbaParcelaEid"])
                daljica_id = str(spd["daljicaEid"])
                pripadnost = spd.get("pripadnost", 0)
                zacTockaEid = daljice_map.get(daljica_id, (None, None))[0]
                konTockaEid = daljice_map.get(daljica_id, (None, None))[1]
                if zacTockaEid is None or konTockaEid is None:
                    print(f"Daljica preskočena (manjka točka): {daljica_id}")
                    continue
                sharedDaljice[parcela_id + zacTockaEid].append(spd)
                sharedDaljice[parcela_id + konTockaEid].append(spd)
                
                stavbe_parcele_daljice_map_obj[daljica_id].append(spd)

                if pripadnost == 0:
                    stavbe_parcele_daljice_map[parcela_id].append(daljica_id)
                else:
                    parcela2daljice_holes[parcela_id][str(pripadnost)].append(daljica_id)            
            
            features = []
            for stavba_id, stavbe_info in stavbe_map.items():
                drawn = False
                for spd in stavbe_parcele_map.get(stavba_id, []):

                    stavba_parcela_id = spd
                    daljice_ids = stavbe_parcele_daljice_map.get(stavba_parcela_id, [])  
                    outer_coords = self.reconstruct_ring(stavba_parcela_id, daljice_ids, sharedDaljice, daljice_map, tocka_map, stavbe_parcele_daljice_map_obj, isStavba=True)    
                    if len(outer_coords) < 3:
                        print(f"Stavba parcela {stavba_parcela_id} nima dovolj koordinat za risanje.")
                        continue

                    holes = []
                    for hole_ids in parcela2daljice_holes[stavba_parcela_id].values():
                        hole_coords = self.reconstruct_ring(stavba_parcela_id, hole_ids, sharedDaljice, daljice_map, tocka_map, stavbe_parcele_daljice_map_obj, isStavba=True)
                        if len(hole_coords) >= 3:
                            holes.append(hole_coords)

                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolygonXY([outer_coords] + holes))

                    drawn = True

                    feat.setAttributes([
                        str(stavbe_info.get("stavbaEid")),  # stavbaEid
                        stavba_parcela_id,  # stavbaParcelaEid)
                        drawn
                    ])
                    features.append(feat)

                if not drawn:
                    geom = None
                    for tryGeom in ("tlorisGeom", "nadzemniGeom", "podzemniGeom", "terenGeom"):
                        if stavbe_info.get(tryGeom):
                            geom = stavbe_info.get(tryGeom)
                            break  
                    if geom:
                        try:
                            geom = QgsGeometry.fromWkt(geom)
                            drawn = True
                            feat = QgsFeature()
                            feat.setGeometry(geom)
                            feat.setAttributes([
                                str(stavbe_info.get("stavbaEid")),
                                None,
                                False
                            ])
                            features.append(feat)
                            print(f"  Uporabljam geom za stavba_id: {stavba_id}")
                        except Exception as e:
                            print(f"  Napaka pri branju geom za stavba_id {stavba_id}: {e}")

                if not drawn:
                    print(f"Stavba parcela {stavba_id} nima veljavnih koordinat ali geometrije.")
                    continue
                    
            if not features:
                QMessageBox.warning(self.dockwidget, "Napaka", "Ni najdenih veljavnih stavb.")
                return
            pr.addFeatures(features)
            vlayer.updateExtents()
            QgsProject.instance().addMapLayer(vlayer)
            self.move_layer_to_group(vlayer)
            self.set_stavbe_style(vlayer)
            self.reorder_layers()

    def reorder_layers(self):
        root = QgsProject.instance().layerTreeRoot()
        group = self.get_or_create_group()
        # Find nodes inside the group
        points_node = None
        stavbe_node = None
        daljice_node = None
        parcele_node = None
        for child in group.children():
            if child.nodeType() == QgsLayerTreeNode.NodeLayer:
                lyr = child.layer()
                if lyr.name() == "Tocke iz XML":
                    points_node = child
                elif lyr.name() == "Stavbe iz XML":
                    stavbe_node = child
                elif lyr.name() == "Daljice iz XML":
                    daljice_node = child
                elif lyr.name() == "Parcele iz XML":
                    parcele_node = child
        # Desired order: Parcele (bottom), Daljice, Stavbe, Tocke (top)
        for node in [parcele_node, daljice_node, stavbe_node, points_node]:
            if node:
                clone = node.clone()
                group.insertChildNode(0, clone)
                group.removeChildNode(node)

    def set_points_style(self, layer):
        symbol = QgsSymbol.defaultSymbol(layer.geometryType())
        symbol_layer = QgsSimpleMarkerSymbolLayer()
        symbol_layer.setColor(Qt.red)
        symbol.changeSymbolLayer(0, symbol_layer)
        layer.renderer().setSymbol(symbol)
        layer.triggerRepaint()

    def set_edges_style(self, layer):
        symbol = QgsSymbol.defaultSymbol(layer.geometryType())
        symbol_layer = QgsSimpleLineSymbolLayer()
        symbol_layer.setColor(Qt.black)
        symbol.changeSymbolLayer(0, symbol_layer)
        layer.renderer().setSymbol(symbol)
        layer.triggerRepaint()

    def set_polygons_style(self, layer):
        field_name = "parcelaEid"
        idx = layer.fields().indexFromName(field_name)
        unique_values = layer.uniqueValues(idx)
        categories = []
        for val in unique_values:
            # Get the hue for this parcelaEid from the attribute (recommended)
            expr = f'"hue"'
            # Get the first feature with this parcelaEid to read its hue
            request = QgsFeatureRequest().setFilterExpression(f'"{field_name}" = \'{val}\'')
            feats = list(layer.getFeatures(request))
            if feats:
                hue = feats[0]["hue"]
            else:
                hue = random.random()
            r, g, b = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
            color = QColor(int(r*255), int(g*255), int(b*255), int(0.6*255))
            symbol = QgsSymbol.defaultSymbol(layer.geometryType())
            symbol.setColor(color)
            symbol.setOpacity(0.2)
            category = QgsRendererCategory(val, symbol, str(val))
            categories.append(category)
        renderer = QgsCategorizedSymbolRenderer(field_name, categories)
        layer.setRenderer(renderer)
        layer.triggerRepaint()   

    def set_stavbe_style(self, layer):
        symbol = QgsSymbol.defaultSymbol(layer.geometryType())
        symbol_layer = QgsSimpleFillSymbolLayer()
        symbol_layer.setColor(QColor(0, 0, 0))
        symbol_layer.setStrokeColor(QColor(0, 0, 0))
        symbol.changeSymbolLayer(0, symbol_layer)
        symbol.setOpacity(0.6)
        layer.renderer().setSymbol(symbol)     

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('UpravjalecElaborata', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/upravljalec_elaborata/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Upravljalec Elaborata'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING UpravjalecElaborata"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD UpravjalecElaborata"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Upravljalec Elaborata'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING UpravjalecElaborata"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = UpravjalecElaborataDockWidget()

            try:
                self.dockwidget.tableWidget_data.cellClicked.disconnect()
            except Exception:
                pass
            self.dockwidget.tableWidget_data.cellClicked.connect(self.handle_table_link_click)

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            # Set project CRS to EPSG:3912
            crs = QgsCoordinateReferenceSystem("EPSG:3794")
            self.dockwidget.pushButton_loadXml.clicked.connect(self.nalozi_xml)

            # Set project CRS to EPSG:3912
            crs = QgsCoordinateReferenceSystem("EPSG:3794")
            QgsProject.instance().setCrs(crs)

    def add_world_basemap(self):
        """Add OpenStreetMap as a basemap if not already present."""
        url = "type=xyz&url=https://tile.openstreetmap.org/{z}/{x}/{y}.png"
        layer_name = "OSM_Map_Vtičnik (lahko brišeš)"
        # Check if already added
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == layer_name:
                return
        basemap = QgsRasterLayer(url, layer_name, "wms")
        if not basemap.isValid():
            basemap = QgsRasterLayer(url, layer_name + "xyz", "xyz")
        if basemap.isValid():
            QgsProject.instance().addMapLayer(basemap)
            self.move_layer_to_group(basemap)

    def get_or_create_group(self, group_name="Upravljalec Elaboratov"):
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(group_name)
        if not group:
            group = root.addGroup(group_name)
        return group        

    def move_layer_to_group(self, layer, group_name="Upravljalec Elaboratov"):
        root = QgsProject.instance().layerTreeRoot()
        group = self.get_or_create_group(group_name)
        node = root.findLayer(layer.id())
        if node and node.parent() != group:
            clone = node.clone()
            group.insertChildNode(0, clone)
            root.removeChildNode(node)
            print("kloniranje sloja")

    def add_xml_to_table(self, elem, level=0):
        # Skip certain tags completely
        if elem.tag in ("prilogeRef", "objekti"):
            return

        row = self.dockwidget.tableWidget_data.rowCount()
        self.dockwidget.tableWidget_data.insertRow(row)
        indent = "    " * level  # 4 spaces per level
        tag_item = QTableWidgetItem(f"{indent}{elem.tag}")
        if len(elem):  # If element has children, make it bold
            font = tag_item.font()
            font.setBold(True)
            tag_item.setFont(font)
        self.dockwidget.tableWidget_data.setItem(row, 0, tag_item)

        # Handle binary/pdf/photo tags
        if elem.tag.lower() == "vsebina":
            if elem.text == None or len(elem.text) < 1:
                self.dockwidget.tableWidget_data.setItem(row, 1, QTableWidgetItem("Brez vsebine"))
                return
            # Assume elem.text is base64-encoded binary
            try:
                binary_data = base64.b64decode(elem.text)
            except Exception:
                binary_data = b""
            link_item = QTableWidgetItem("Odpri datoteko")
            link_item.setForeground(Qt.blue)
            link_item.setFlags(link_item.flags() | Qt.ItemIsEditable)
            link_item.setData(Qt.UserRole, binary_data)
            self.dockwidget.tableWidget_data.setItem(row, 1, link_item)
        else:
            text = elem.text.strip() if elem.text else ""
            self.dockwidget.tableWidget_data.setItem(row, 1, QTableWidgetItem(text))

        # Recursively add children
        for child in elem:
            self.add_xml_to_table(child, level + 1)

    def handle_table_link_click(self, row, column):
        item = self.dockwidget.tableWidget_data.item(row, column)
        if item and item.text() == "Odpri datoteko":
            binary_data = item.data(Qt.UserRole)
            if binary_data:
                filename, _ = QFileDialog.getSaveFileName(
                    self.dockwidget,
                    "Shrani datoteko",
                    "",
                    "PDF Files (*.pdf);;All Files (*)"
                )
                if filename:
                    # Add .pdf extension if missing
                    if not filename.lower().endswith('.pdf'):
                        filename += '.pdf'
                    with open(filename, 'wb') as f:
                        f.write(binary_data)
